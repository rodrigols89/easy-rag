# Easy RAG

## Conte√∫do

 - [`Adicionando .editorconfig e .gitignore`](#editorconfig-gitignore)
 - [`Iniciando o projeto com "poetry init"`](#poetry-init)
 - [`Instalando e configurando o Ruff`](#ruff-settings-pyproject)
 - [`Instalando e configurando o Pytest`](#pytest-settings-pyproject)
 - [`Instalando e configurando o Taskipy`](#taskipy-settings-pyproject)
 - [`Instalando e configurando o pre-commit`](#precommit-settings)
 - [`Criando os docker-compose da nossa aplica√ß√£o`](#init-docker-compose)
 - [`Instalando o Django e criando o projeto "core"`](#install-django-core)
 - [`Configur√ß√µes iniciais do Django (templates, static, media)`](#init-django-settings)
 - [`Criando o App "frontend" e a p√°gina index.html`](#index-landing)
 - [`Criando a p√°gina de cadastro (create-account.html)`](#create-account)
 - [`Instalando a biblioteca psycopg2-binary`](#psycopg2-binary)
<!---
[WHITESPACE RULES]
- "40" Whitespace character.
--->








































---

<div id="editorconfig-gitignore"></div>

## `Adicionando .editorconfig e .gitignore`

De in√≠cio vamos adicionar os arquivos `.editorconfig` e `.gitignore` na raiz do projeto:

[.editorconfig](../.editorconfig)
```conf
# top-most EditorConfig file
root = true

# Unix-style newlines with a newline ending every file
[*]
end_of_line = lf
insert_final_newline = true
charset = utf-8

# 4 space indentation
[*.{py,html, js}]
indent_style = space
indent_size = 4

# 2 space indentation
[*.{json,y{a,}ml,cwl}]
indent_style = space
indent_size = 2
```

[.gitignore](../.gitignore)
```conf

√â muito grande n√£o vou exibir...
```








































---

<div id="poetry-init"></div>

## `Iniciando o projeto com "poetry init"`

Agora vamos iniciar nosso projeto com `poetry init`:

```bash
poetry init
```









































---

<div id="ruff-settings-pyproject"></div>

## `Instalando e configurando o Ruff`

Aqui vamos instalar e configurar o **Ruff** no nosso `pyproject.toml`:

```bash
poetry add --group dev ruff@latest
```

> Esse bloco define √†s *Regras Gerais de funcionamento do (Ruff)*.

#### `[tool.ruff]`

```toml
[tool.ruff]
line-length = 79
exclude = [
    "core/settings.py",
]
```

 - `line-length = 79`
   - Define que nenhuma linha de c√≥digo deve ultrapassar 79 caracteres *(seguindo o padr√£o tradicional do PEP 8)*.
   - √â especialmente √∫til para manter legibilidade em terminais com largura limitada.
   - Ruff ir√° avisar (e, se poss√≠vel, corrigir) quando encontrar linhas mais longas.
 - `exclude = ["core/settings.py"]`
   - Define quais arquivos o Ruff deve ignorar:
     - Nesse caso, ele vai ignorar o arquivo `core/settings.py`.

#### `[tool.ruff.lint]`

Esse √© o sub-bloco principal de configura√ß√£o de linting do Ruff, ou seja, onde voc√™ define como o Ruff deve analisar o c√≥digo quanto a erros, estilo, boas pr√°ticas etc.

```toml
[tool.ruff.lint]
preview = true
select = ['I', 'F', 'E', 'W', 'PL', 'PT']
```

 - `preview = true`
   - Ativa regras experimentais (em fase de teste, mas est√°veis o suficiente).
   - Pode incluir novas verifica√ß√µes que ainda n√£o fazem parte do conjunto padr√£o.
   - √ötil se voc√™ quer estar sempre com o Ruff mais ‚Äúrigoroso‚Äù e atualizado.
 - `select = ['I', 'F', 'E', 'W', 'PL', 'PT']`
   - Define quais conjuntos de regras (lints) o Ruff deve aplicar ao seu c√≥digo. Cada uma dessas letras corresponde a um grupo de regras:
     - `I` ([Isort](https://pycqa.github.io/isort/)): Ordena√ß√£o de imports em ordem alfab√©tica.
     - `F` ([Pyflakes](https://github.com/PyCQA/pyflakes)): Procura por alguns erros em rela√ß√£o a boas pr√°ticas de c√≥digo.
     - `E` ([pycodestyle](https://pycodestyle.pycqa.org/en/latest/)): Erros de estilo de c√≥digo.
     - `W` ([pycodestyle](https://pycodestyle.pycqa.org/en/latest/)): Avisos sobre estilo de c√≥digo.
     - `PL` ([Pylint](https://pylint.pycqa.org/en/latest/index.html)): "erros" em rela√ß√£o a boas pr√°ticas de c√≥digo.
     - `PT` ([flake8-pytest](https://pypi.org/project/flake8-pytest-style/)): Boas pr√°ticas do Pytest.

#### `[tool.ruff.format]`

O bloco [tool.ruff.format] √© usado para configurar o formatador interno do Ruff, que foi introduzido recentemente como uma alternativa ao Black ‚Äî mas com a vantagem de ser muito mais r√°pido.

```toml
[tool.ruff.format]
preview = true
quote-style = "double"
```

 - `preview = true`
   - Ativa regras experimentais (em fase de teste, mas est√°veis o suficiente).
 - `quote-style = "double"`
   - Define o estilo de aspas (duplas no nosso caso) usadas pelo formatador.









































---

<div id="pytest-settings-pyproject"></div>

## `Instalando e configurando o Pytest`

Agora n√≥s vamos instalar e configurar o **Pytest** no nosso `pyproject.toml`.

```bash
poetry add --group dev pytest@latest
```

#### `[tool.pytest.ini_options]`

O bloco `[tool.pytest.ini_options]` no `pyproject.toml` √© usado para configurar o comportamento do Pytest, da mesma forma que voc√™ faria com `pytest.ini`, `setup.cfg` ou `tox.ini`:

```toml
[tool.pytest.ini_options]
pythonpath = "."
addopts = '-p no:warnings'
```

 - `pythonpath = "."`
   - Onde o Pytest procurar arquivos Python para executar.
   - Ou seja, a partir da `raiz (.)` do nosso projeto.
 - `addopts = '-p no:warnings'`
   - Para ter uma visualiza√ß√£o mais limpa dos testes, caso alguma biblioteca exiba uma mensagem de warning, isso ser√° suprimido pelo pytest.









































---

<div id="taskipy-settings-pyproject"></div>

## `Instalando e configurando o Taskipy`

Agora n√≥s vamos instalar e configurar o **Taskipy** no nosso `pyproject.toml`.

```bash
poetry add --group dev taskipy@latest
```

#### `[tool.taskipy.tasks]`

O bloco `[tool.taskipy.tasks]` √© usado para definir *tarefas (tasks)* autom√°ticas personalizadas no seu `pyproject.toml`, usando o pacote taskipy.

```toml
[tool.taskipy.tasks]
lint = 'ruff check'
pre_format = 'ruff check --fix'
format = 'ruff format'
pre_test = 'task lint'
test = 'pytest -s -x --cov=. -vv'
post_test = 'coverage html'
```

 - `lint = 'ruff check'`
   - Executa o Ruff para verificar erros de estilo e c√≥digo (linting), sem alterar nada.
 - `pre_format = 'ruff check --fix'`
   - Executa antes da *tarefa (task)* `format`. Aqui, voc√™ corrige automaticamente os erros encontrados por Ruff.
 - `format = 'ruff format'`
   - Usa o formatador nativo do Ruff (em vez de Black) para aplicar formata√ß√£o ao c√≥digo. 
 - `pre_test = 'task lint'`
   - Antes de rodar os testes, executa a tarefa lint (garantindo que o c√≥digo est√° limpo).
 - `test = 'pytest -s -x --cov=. -vv'`
   - Roda os testes com Pytest, com as seguintes op√ß√µes:
     - `-s`: Mostra print() e input() no terminal.
     - `-x`: Interrompe no primeiro erro.
     - `--cov=.`: Mede cobertura de testes com o plugin pytest-cov
     - `-vv`: Verbosidade extra (mostra todos os testes)
 - `post_test = 'coverage html'`
   - Depois dos testes, gera um relat√≥rio HTML de cobertura que voc√™ pode abrir no navegador (geralmente em htmlcov/index.html).









































---

<div id="precommit-settings"></div>

## `Instalando e configurando o pre-commit`

Para garantir que antes de cada commit seu projeto passe por:

 - ‚úÖ lint (usando Ruff)
 - ‚úÖ test (com pytest)
 - ‚úÖ coverage

Voc√™ deve usar o pre-commit ‚Äî uma ferramenta leve e ideal para isso. Vamos configurar passo a passo:

```bash
poetry add --group dev pre-commit
```

[.pre-commit-config.yaml](../.pre-commit-config.yaml)
```yaml
repos:
  - repo: local
    hooks:
      - id: ruff-lint
        name: ruff check
        entry: task lint
        language: system
        types: [python]

      - id: pytest-test
        name: pytest test
        entry: task test
        language: system
        types: [python]

      - id: pytest-coverage
        name: pytest coverage
        entry: task post_test
        language: system
        types: [python]
```

Agora n√≥s precisamos instalar o pre-commit:

```bash
pre-commit install
```

#### Dica extra: Se quiser rodar manualmente

```bash
pre-commit run --all-files
```

> **NOTE:**  
> √â interessante ter uma checagem r√°pida no Taskipy.

[pyproject.toml](../pyproject.toml)
```toml
[tool.taskipy.tasks]
precommit = 'pre-commit run --all-files'
```









































---

<div id="init-docker-compose"></div>

## `Criando os docker-compose da nossa aplica√ß√£o`

√â comum em uma aplica√ß√£o ter os seguintes *docker-composes*:

 - [‚öôÔ∏è 1. docker-compose.yml (base comum)](../docker-compose.yml)
   - Esse √© o arquivo principal, usado em todos os ambientes.
   - Define apenas o servi√ßo de banco, os volumes e a rede.
   - üëâ Esse arquivo nunca muda, nem em dev nem em prod ‚Äî √© a base do projeto.
 - [‚öôÔ∏è 2. Docker-compose.dev.yml](../docker-compose.dev.yml)
   - Para desenvolvimento, o que muda normalmente √©:
     - Expor a porta do banco localmente (5432:5432);
     - Permitir acesso de ferramentas como DBeaver, PgAdmin ou psql;
     - Log mais detalhado.
   - üí° Aqui n√£o precisamos repetir image, volumes, etc. ‚Äî o Docker herda tudo do base e apenas aplica o override.
 - [‚öôÔ∏è 3. Docker-compose.prod.yml](../docker-compose.prod.yml)
   - Na produ√ß√£o, normalmente:
     - N√£o expomos a porta 5432 (para seguran√ßa);
     - Mantemos o banco acess√≠vel apenas pela rede interna do Docker;
     - Ativamos backup automatizado (opcional mais pra frente).
   - ‚ö†Ô∏è expose deixa a porta vis√≠vel apenas dentro da rede Docker, sem expor para o host ou internet.

Agora vamos criar comandos no Taskipy para executar cada um dos docker-compose:

[pyproject.toml](../pyproject.toml)
```toml
[tool.taskipy.tasks]
prodcompose = 'docker compose -f docker-compose.yml -f docker-compose.prod.yml up --build -d'
devcompose = 'docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d'
```









































---

<div id="install-django-core"></div>

## `Instalando o Django e criando o projeto "core"`

Agora n√≥s vamos instalar o Django e criar o projeto `core`:

```bash
poetry add django@latest
```

```bash
django-admin startproject core .
```

> **NOTE:**  
> Uma coisa importante agora √© excluir o arquivo `core/settings.py` do ruff:

[pyproject.toml](../pyproject.toml)
```bash
[tool.ruff]
line-length = 79
exclude = [
    "core/settings.py",
]
```

> **NOTE:**  
> Agora esse arquivo n√£o vai mais passar pelo `lint`.

Agora para testar se tudo est√° funcionando, vamos rodar o servidor:

```bash
python manage.py runserver
```

 - [http://localhost:8000/](http://localhost:8000/)

Aqui tamb√©m √© interessanter ter um comando s√≥ para rodar o servidor:

[pyproject.toml](../pyproject.toml)
```toml
[tool.taskipy.tasks]
runserver = 'python manage.py runserver'
```












































---

<div id="init-django-settings"></div>

## `Configura√ß√µes iniciais do Django (templates, static, media)`

Aqui n√≥s vamos fazer as configura√ß√µes iniciais do Django que ser√£o:

> Fazer o Django identificar onde estar√£o os arquivos `templates`, `static` e `media`:

[core/settings.py](../core/settings.py)
```python
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]



STATIC_URL = '/static/'
STATICFILES_DIRS = [BASE_DIR / 'static']
STATIC_ROOT = BASE_DIR / 'staticfiles'

MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'
```









































---

<div id="index-landing"></div>

## `Criando o App "frontend" e a p√°gina index.html`

> Bem, uma abordagem interessante (√© a que vamos utilizar) √© ter um projeto separado por **frontend** do **backend**.

De In√≠cio vamos criar (e configurar) o App `frontend` que ser√° respons√°vel por cuidar do frontend do projeto:

```bash
python manage.py startapp frontend
```

[core/settings.py](../core/settings.py)
```python
INSTALLED_APPS = [

    ....
    'frontend',
]
```

> **NOTE:**  
> Bem, se voc√™s pensarem comigo o ideal √© que quando algu√©m entre no nosso projeto (site) j√° v√° direto para a p√°gina `home.html` (a menos que ele j√° esteja logado √© claro).

Na verdade essa p√°gina n√£o vai se chamar `home.html` e sim `index.html`:

[frontend/templates/pages/index.html](../frontend/templates/pages/index.html)
```html
{% extends "base.html" %}

{% block title %}Easy RAG{% endblock %}

{% block content %}
    <h1>Easy RAG</h1>

    <!-- Formul√°rio de login b√°sico -->
    <form method="post" action="">
        {% csrf_token %}
        <!-- Username -->
        <div>
            <label for="username">Username</label><br>
            <input type="text"
                id="username"
                name="username"
                autocomplete="username"
                required>
        </div>
        <!-- Password -->
        <div>
            <label for="password">Password</label><br>
            <input type="password"
                id="password"
                name="password"
                autocomplete="current-password"
                required>
        </div>
        <!-- Bot√£o de submit -->
        <div>
            <button type="submit">Entrar</button>
        </div>
    </form>

    <br/>

    <!-- Bot√µes para login social (placeholders) -->
    <div>
        <a href="">
            <button type="button">Entrar com Google</button>
        </a>
        <a href="">
            <button type="button">Entrar com GitHub</button>
        </a>
    </div>

    <br/>

    <!-- Link para cadastro -->
    <div>
        <a href="">Cadastrar</a>
    </div>
{% endblock %}
```

Isso √© o que n√≥s conhecemos como `landing page`, geralmente uma `landing page` p√∫blica contem:

 - Apresenta√ß√£o do produto/servi√ßo.
 - Bot√µes de ‚ÄúEntrar‚Äù e ‚ÄúCadastrar‚Äù.
 - Sess√µes com informa√ß√µes sobre a empresa.
 - Depoimentos, pre√ßos, etc.

Agora vamos configurar uma rota/url para assim que algu√©m abrir nosso projeto (site) seja direcionado para essa `landing page` (a menos que ele j√° esteja logado √© claro):

[core/urls.py](../core/urls.py)
```python
from django.contrib import admin
from django.urls import include, path

urlpatterns = [
    path("admin/", admin.site.urls),
    path("", include("frontend.urls")),
]
```

[frontend/urls.py](../frontend/urls.py)
```python
from django.urls import path

from .views import index

urlpatterns = [
    path(route="", view=index, name="index"),
]
```

[frontend/views.py](../frontend/views.py)
```python
from django.shortcuts import render


def index(request):
    if request.method == "GET":
        return render(request, "pages/index.html")
```

Finalmente, se voc√™ abrir o projeto (site) na rota/url principal vai aparecer essa `landing page`.

 - [http://localhost:8000/](http://localhost:8000/)










































---

<div id="create-account"></div>

## `Criando a p√°gina de cadastro (create-account.html)`

> Aqui n√≥s vamos apenas criar e configurar a rota/url para a nossa `p√°gina de cadastro`.

[frontend/templates/pages/create-account.html](../frontend/templates/pages/create-account.html)
```html
{% extends "base.html" %}

{% block title %}Criar Conta ‚Äî Easy RAG{% endblock %}

{% block content %}
    <h1>Criar Conta</h1>

    <!-- Formul√°rio de cadastro -->
    <form method="post" action="">
    {% csrf_token %}

        <!-- Username -->
        <div>
            <label for="username">Username</label><br>
            <input type="text"
                    id="username"
                    name="username"
                    autocomplete="username"
                    required>
        </div>

        <!-- Email -->
        <div>
            <label for="email">Email</label><br>
            <input type="email"
                    id="email"
                    name="email"
                    autocomplete="email"
                    required>
        </div>

        <!-- Password -->
        <div>
            <label for="password1">Senha</label><br>
            <input type="password"
                    id="password1"
                    name="password1"
                    autocomplete="new-password"
                    required>
        </div>

        <!-- Confirm Password -->
        <div>
            <label for="password2">Confirmar Senha</label><br>
            <input type="password"
                    id="password2"
                    name="password2"
                    autocomplete="new-password"
                    required>
        </div>

        <!-- Bot√£o de submit -->
        <div>
            <button type="submit">Cadastrar</button>
        </div>

    </form>

    <br/>

    <!-- Link para voltar ao login -->
    <div>
        <a href="/">J√° tem uma conta? Fazer login</a>
    </div>
{% endblock %}
```

Agora vamos criar uma rota/url para essa `p√°gina de cadastro`:

[frontend/urls.py](../frontend/urls.py)
```python
from django.urls import path

from .views import index, create_account

urlpatterns = [
    path(route="", view=index, name="index"),
    path(route="create-account/", view=create_account, name="create-account"),
]
```

Agora vamos criar uma view (a√ß√£o) para essa `p√°gina de cadastro`:

[frontend/views.py](../frontend/views.py)
```python
from django.shortcuts import render


def create_account(request):
    if request.method == "GET":
        return render(request, "pages/create-account.html")
```

> **Mas como acessar essa p√°gina?**

Bem, n√≥s precisamos modificar o `index.html` para sempre que algum usu√°rio clicar em "Cadastrar", ele seja redirecionado para essa `p√°gina de cadastro`:

[frontend/templates/pages/index.html](../frontend/templates/pages/index.html)
```html
<!-- Link para cadastro -->
<div>
    <a href="{% url 'create-account' %}">Cadastrar</a>
</div>
```

> **NOTE:**  
> Lembrando que n√≥s temos que fazer o mesmo na p√°gina de cadastro para voltar ao login.

[frontend/templates/pages/create-account.html](../frontend/templates/pages/create-account.html)
```html
<!-- Link para voltar ao login -->
<div>
    <a href="/">J√° tem uma conta? Fazer login</a>
</div>
```











































---

<div id="psycopg2-binary"></div>

## `Instalando a biblioteca psycopg2-binary`

 - Este √© o driver oficial do PostgreSQL para Python ‚Äî o Django usa ele internamente para conversar com o banco.
 - **NOTE:** Sem ele, o Django n√£o consegue abrir a conex√£o porque depende de um driver nativo espec√≠fico do PostgreSQL.

```bash
poetry add psycopg2-binary@latest
```

#### `‚öôÔ∏è 2. O que o psycopg2-binary faz?`

> Ele √© a ponte entre o Django (Python) e o PostgreSQL (servidor).

Quando o Django executa algo como:

```bash
User.objects.create(username="drigols")
```

internamente ele faz uma chamada SQL tipo:

```sql
INSERT INTO auth_user (username) VALUES ('drigols');
```

Mas pra enviar isso ao PostgreSQL, ele precisa de uma biblioteca cliente ‚Äî e √© a√≠ que entra o psycopg2.


































































































---

**Rodrigo** **L**eite da **S**ilva - **rodrigols89**
